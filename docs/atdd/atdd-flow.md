# ATDD（受け入れテスト駆動開発）フロー

このドキュメントは、ATDD（Acceptance Test-Driven Development）の理想的なフローを説明します。

## ATDDとは

ATDDは、受け入れ基準を先に定義し、それに基づいてテストを作成してから実装を行う開発手法です。以下の利点があります：

- **共通理解**: ステークホルダー、開発者、テスターが同じ受け入れ基準を共有
- **品質保証**: 実装前にテストを定義することで、要件の曖昧さを排除
- **回帰テスト**: 自動化されたテストが継続的な品質を保証
- **ドキュメント**: テストケース自体が実行可能な仕様書となる

---

## 理想的なATDDフロー

### ステップ1: ユーザーストーリーと受け入れ基準の定義

**目的**: 何を作るかを明確にする

```
ユーザーストーリー: デフォルトポモドーロモード
As a ユーザー
I want to シンプルなポモドーロタイマーを使用する
So that 作業と休憩のサイクルを簡単に管理できる

受け入れ基準（AC）:
- AC 1.1: スタートボタンで25分タイマー開始
- AC 1.2: 完了時に5秒間ビープ音
- AC 1.3: 一時停止・再開機能
- AC 1.4: 停止機能
```

**成果物**: `acceptance.md`

### ステップ2: テストシナリオの作成

**目的**: 受け入れ基準を具体的なテストケースに変換

受け入れ基準から、Given/When/Then形式のテストシナリオを作成します。

```
機能カテゴリ: デフォルトモード - 基本操作
No: 1-1
Given: アプリが待機状態（idle）である
When: スタートボタンをクリックする
Then: タイマーが25分（設定値）でカウントダウンを開始し、作業中の画面になる
```

**成果物**: `scenario-test-case.tsv`

### ステップ3: 自動テストの作成（Red）

**目的**: テストファースト

```typescript
// 例: PlannedMode.test.tsx
it('should auto-fill work end and break end when start time is changed', () => {
  render(<PlannedMode {...props} />);

  const startTimeInput = screen.getAllByDisplayValue(/^\d{2}:\d{2}$/)[0];
  fireEvent.change(startTimeInput, { target: { value: '10:00' } });

  // まだ実装されていないので失敗する
  expect(screen.getAllByDisplayValue(/^\d{2}:\d{2}$/)[1].value).toBe('10:25');
});
```

**成果物**: 失敗するテスト（Redフェーズ）

### ステップ4: 実装（Green）

**目的**: テストを通すための最小限の実装

```typescript
// PlannedMode.tsx
const handleStartTimeChange = (newStartTime: string) => {
  setNewPomodoroStartTime(newStartTime);
  const workEnd = calculateTimeFromDuration(newStartTime, context.settings.workDuration);
  const breakEnd = calculateTimeFromDuration(workEnd, context.settings.breakDuration);
  setNewPomodoroWorkEndTime(workEnd);
  setNewPomodoroBreakEndTime(breakEnd);
};
```

**成果物**: テストが通る実装（Greenフェーズ）

### ステップ5: リファクタリング（Refactor）

**目的**: コードの品質向上

- コードの重複を削除
- 可読性の向上
- パフォーマンスの最適化

**成果物**: 改善されたコード（テストは引き続き成功）

### ステップ6: 受け入れテストの実施

**目的**: エンドツーエンドでの動作確認

`scenario-test-case.tsv` のテストケースを手動または自動で実行し、受け入れ基準を満たしていることを確認します。

---

## ATDDで重要なポイント

### ✅ ATDDの成功要因

1. **包括的なテストカバレッジ**
   - 自動テスト（ユニット、インテグレーション）
   - シナリオテストケース（手動または自動）
   - 全機能に対する網羅的なテスト

2. **明確な受け入れ基準**
   - 全機能に対してACを定義
   - Given/When/Then形式で明確に記述
   - ステークホルダーと開発者が共通理解を持つ

3. **状態管理の明確化**
   - 状態遷移を明示的に設計（例: XState）
   - テスト可能なアーキテクチャ
   - 複雑な状態を管理しやすい構造

4. **ドキュメントの整備**
   - acceptance.md: ユーザーストーリーとAC
   - scenario-test-case.tsv: テストシナリオ
   - 実行可能な仕様書としてのテストコード

### ⚠️ ATDDでよくある間違い

1. **テストファーストを守らない**
   - ❌ 間違い: 実装 → テスト
   - ✅ 正しい: テスト → 実装
   - **なぜ重要か**: テストを先に書くことで、インターフェース設計が改善され、実装の方向性が明確になる

2. **受け入れ基準を後回しにする**
   - ❌ 間違い: 実装 → AC整理
   - ✅ 正しい: AC定義 → テスト → 実装
   - **なぜ重要か**: 事前のAC定義により、要件の曖昧さや矛盾を早期に発見できる

3. **ステークホルダーとの対話が不足**
   - ❌ 間違い: 最初と最後だけのレビュー
   - ✅ 正しい: 各イテレーションで受け入れテストを実施
   - **なぜ重要か**: 継続的なフィードバックにより、方向性のズレを早期に修正できる

---

## ATDDを実践するためのチェックリスト

次のプロジェクトでATDDを実践する際は、以下のチェックリストを使用してください：

### 計画フェーズ
- [ ] ユーザーストーリーを定義（As a/I want to/So that）
- [ ] 各ストーリーに受け入れ基準（AC）を定義
- [ ] ACをチーム全体でレビュー（開発者、QA、PO）

### テスト設計フェーズ
- [ ] ACからテストシナリオを作成（Given/When/Then）
- [ ] テストシナリオをTSV等で管理
- [ ] 自動化可能なテストを識別

### 開発フェーズ
- [ ] 失敗するテストを先に書く（Red）
- [ ] 最小限の実装でテストを通す（Green）
- [ ] リファクタリング（Refactor）
- [ ] テストが全て成功することを確認

### 受け入れフェーズ
- [ ] シナリオテストケースを実施
- [ ] ステークホルダーによる受け入れテスト
- [ ] フィードバックを次のイテレーションに反映

---

## 参考資料

### ATDD関連ドキュメント

| ドキュメント | 役割 | ATDDのステップ |
|------------|------|--------------|
| [`acceptance.md`](./acceptance.md) | ユーザーストーリーと受け入れ基準 | ステップ1 |
| [`scenario-test-case.tsv`](./scenario-test-case.tsv) | テストシナリオ | ステップ2 |
| `../../app/**/__tests__/*.test.tsx` | 自動テスト | ステップ3-5 |
| [`atdd-flow.md`](./atdd-flow.md)（このドキュメント） | ATDDプロセスガイド | メタドキュメント |

### テスト実行コマンド

```bash
# ユニットテスト・インテグレーションテスト（自動）
npm test

# シナリオテストケースの確認（手動）
# scenario-test-case.tsv を参照して手動テスト
```

---

## まとめ

**ATDDの核心**は：
1. **何を作るか**を先に明確にする（受け入れ基準）
2. **どう確認するか**を先に定義する（テストシナリオ）
3. **テストを通す**ために実装する（実装）

このサイクルを回すことで、要件の曖昧さが減り、高品質なソフトウェアが効率的に開発できます。
